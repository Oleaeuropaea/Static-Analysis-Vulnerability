__all__ = ['StackFrame', 'Value']

ARCHITECTURE = 32
ADDRESS_SIZE = ARCHITECTURE // 8
MAIN_ARGS_SIZE = 8

class Value: # int to bytes (https://stackoverflow.com/questions/21017698/converting-int-to-bytes-in-python-3)
    def __init__(
            self, address=None, name=None, value=None, size=ADDRESS_SIZE,
            maxSize=ADDRESS_SIZE, isEnded=True, spec=None, includedIn=None, frameIdx=None):
        self.address = address
        self.name = name
        self.value = value
        self.size = size
        self.maxSize = maxSize
        self.isEnded = isEnded
        self.spec = spec
        self.includedIn = includedIn
        self.frameIdx = frameIdx

    def isEmpty(self):
        return not self.name and not self.value

    def isSpecial(self):
        return self.spec is not None

def myDec(value, dec):
    if value:
        value = value - dec
        value = value if value > 0 else 0
    return value

def findVar(stack, varName):
    for idx, val in enumerate(stack):
        if varName == val.name:
            return idx, val

def findConcurrent(stack, val):
    ival = val.address
    fval = ival - val.maxSize
    for idx, sv in enumerate(stack):
        isv = sv.address
        fsv = isv - sv.maxSize
        if isv >= ival and fval >= fsv:
            return idx, sv

    print('Estranho muito estranho')

class StackFrame:
    '''
          The stack frame has the address inverted and includes the
        return address in the frame as shown in the following scheme:

                FFFF                 ____
                    |   ...   |         |
                    |_________|         |
         address -> |   BUFF  |         |
                    |         |         |
                    |_________|         |
                    |   ...   |         |   Stack Frame
                    |_________|         |
             rbp -> |   RBP   |         |
                    |_________|         |
                    |   RET   |         |
                    |_________|     ____|
                0000
    '''

    def __init__(self, name, lsp=0):
        self._name = name
        self._frame = [
            Value(4, spec='ret', includedIn=self, frameIdx=0),
            Value(8, spec='rbp', includedIn=self, frameIdx=1),
        ]
        bp = lsp + 8
        self.bp = bp
        self.sp = bp

    def getFrameName(self):
        return self._name

    def pushValue(self, value):
        value.includedIn = self
        value.frameIdx = len(self._frame)
        self.sp = self.sp + value.maxSize
        value.address = self.sp
        self._frame.append(value)

    def allocateChunck(self, amount):
        self.sp = self.sp + amount
        val = Value(self.sp, size=0, maxSize=amount, includedIn=self, frameIdx=len(self._frame))
        self._frame.append(val)

    # Assumption: the space is allocated before insert the val
    def insert(self, val):
        val.includedIn = self

        val.address = val.address + self.bp

        idx, sv = findConcurrent(self._frame, val)

        svMax = sv.maxSize
        svEnd = sv.address - sv.maxSize
        valEnd = val.address - val.maxSize

        if sv.address == val.address:
            del self._frame[idx]
        else:
            sv.maxSize = sv.address - val.address

        self._frame.insert(idx, val)

        if sv.address - svMax != valEnd:
            self._frame.insert(
                idx,
                Value(valEnd, size=0, maxSize=valEnd - svEnd, includedIn=self) # TODO Review size (case: insert int)
            )

        self.updateIndexes()

    def updateIndexes(self):
        for idx, fv in enumerate(self._frame):
            fv.frameIdx = idx

    def getIdxValue(self, idx):
        return self._frame[idx]


    def get_value(self, offset_bp):   # Supporting only the request of the value using address of beginning 
                                # TODO: Maybe add further support (request middle value)
        if offset_bp < -4:
            return None
        elif offset_bp == -4:
            return self._frame[0]

        addr = self.bp + offset_bp
        for val in self._frame[1:]:
            #valEnd = val.address - val.maxSize
            #if not(val.address >= addr and addr < valEnd):
                #return None
            if val.address == addr and (val.name or val.spec):
                return val

    def set_value(self, offset_bp, val):    # Supporting only the request of the value using address of beginning 
                                            # TODO: Maybe add further support (request middle value)
        valueObj = self.get_value(offset_bp)
        valueObj.value = val

    def checkVuln(self, var, size=None):
    #def checkVuln(self, varName, size=None):
        #idx, var = findVar(self._frame, varName)
        idx = self._frame.index(var)
        varName = var.name

        size = myDec(size, var.maxSize)
        if size is not None and size < 1:
            return [], size

        vulns = []
        for i in reversed(range(2, idx)):
            v = self._frame[i]

            if v.name:
                vulns.append({
                    'vulnerability': 'VAROVERFLOW',
                    'vuln_function': self._name,
                    'overflow_var': varName,
                    'overflown_var': v.name
                })
            else:
                vulns.append({
                    'vulnerability': 'INVALIDACCS',
                    'vuln_function': self._name,
                    'overflow_var': varName,
                    'overflown_address': 'rbp-0x%x' % (v.address - self.bp)
                })
            
            size = myDec(size, v.maxSize)
            if size is not None and size < 1:
                return vulns, size

        vulns.append({
            'vulnerability': 'RBPOVERFLOW',
            'vuln_function': self._name,
            'overflow_var': varName
        })
        size = myDec(size, ADDRESS_SIZE)

        if size is None or size > 0:
            vulns.append({
                'vulnerability': 'RETOVERFLOW',
                'vuln_function': self._name,
                'overflow_var': varName
            })
            size = myDec(size, ADDRESS_SIZE)

        return vulns, size

    def checkCorruption(self, size=None, mainDone=False):
        if size is not None and size == 0:
            return None, size

        if not mainDone:
            for v in reversed(self._frame):
                size = myDec(size, v.maxSize)
                if size is not None and size == 0:
                    return None, size

        if size is not None:
            size = size - MAIN_ARGS_SIZE  # TODO: Check to do below
            if size <= 0:
                return None, size

        vuln = {
            "vulnerability": "SCORRUPTION",
            "vuln_function": self._name,
            "overflown_address": "rbp+0x10" # TODO: Ask the professor why it is plus 0x10 (16) instead of 0x8
                                            #       (because of the parameters on regeisters)
        }

        return vuln, size


    