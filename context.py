__all__ = ['Context']

from stackFrame import StackFrame
from register import Register

registers = ['ax','bx','cx','dx','di','si','8','9','10','11','12','13','14','15','bp','sp','ip']


def getFrameOffset(stack, offset_rbp):
    fIdx = len(stack) - 1
    frame = stack[fIdx]
    while offset_rbp < -4:
        fIdx = fIdx - 1
        if fIdx < 0:
            raise Exception('Offset out of Stack')

        frame = stack[fIdx]

        offset_rbp = offset_rbp + frame.sp

    return (frame, offset_rbp)
    

class Context:
    def __init__(self, code):
        initialFrame = StackFrame('main')
        self._stack = [initialFrame]
        self._regs = dict()     
        self._code = code
        self._ic = [0]
        for r in registers:
           newRegister = Register(r)
           self._regs[newRegister.getName()] = newRegister

    def get_ic(self):
        return self._ic[0]

    def set_ic(self, value):
        self._ic[0] = value
        return value

    def inc_ic(self):
        return self.set_ic(self._ic[0] + 1)

    def getRegisterValue(self, name):
        nameTrimmed = name[1:]
        return self._regs[nameTrimmed].getValue(name)

    def setRegisterValue(self, name, value):
        nameTrimmed = name[1:]
        return self._regs[nameTrimmed].setValue(name, value)

    def getRegisters(self):
        return self._regs

    def getCode(self, name):
        return self._code[name]

    def newStackFrame(self, name):
        currFrame = self.getStakeFrame()
        lsp = currFrame.sp
        frame = StackFrame(name, lsp)
        self._stack.append(frame)
        self._ic.insert(0, 0)

    def getStakeFrame(self):
        return self._stack[-1]

    def inactivateFrame(self):
        self._stack.pop()
        self._ic = self._ic[1:]

    def getStackValue(self, offset_rbp):
        frame, offset_rbp = getFrameOffset(self._stack, offset_rbp)
        return frame.get_value(offset_rbp)

    def setStackValue(self, offset_rbp, val):
        frame, offset_rbp = getFrameOffset(self._stack, offset_rbp)
        frame.set_value(offset_rbp, val)

    def pushNewStackValue(self, value):
        currFrame = self.getStakeFrame()
        currFrame.pushValue(value)

    def allocateChunck(self, amount):
        frame = self.getStakeFrame()
        return frame.allocateChunck(amount)

    def insert(self, val):
        frame = self.getStakeFrame()
        return frame.insert(val)

    def checkVuln(self, var, size=None):
        currFrame = self.getStakeFrame()
        vulns, size = currFrame.checkVuln(var, size=size)

        for f in self._stack[1:-1]:
            _, size = f.checkCorruption(size)

        mainFrame = self._stack[0]
        mainDone = currFrame.getFrameName() == 'main'
        vuln, size = mainFrame.checkCorruption(size, mainDone=mainDone)

        if vuln is not None:
            vuln.setdefault('overflow_var', var.name)
            vulns.append(vuln)
        
        return vulns

    def nextStackValue(self, val):
        frame = val.includedIn

        valueIdx = val.frameIdx
        if valueIdx != 0:
            return frame.getIdxValue(valueIdx - 1)

        frameIdx = self._stack.index(frame)
        if frameIdx == 0:
            return None

        nextFrame = self._stack[frameIdx - 1]

        return nextFrame.getIdxValue(-1)
