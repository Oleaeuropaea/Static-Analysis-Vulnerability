import struct

from opProcessor import OpProcessor
from stackFrame import Value
from re import fullmatch

class NopProcessor(OpProcessor):
    def __init__(self):
        super().__init__('nop')

class AddProcessor(OpProcessor):
    def __init__(self, context):
        super().__init__('add')
        self._ctx = context

    def process(self, inst):
        super().process(inst)
        args = inst['args']
        if args['dest'] == 'rsp':
            value = int(args['value'], base=16)
            packedValue = struct.pack('Q', value)
            value = struct.unpack('q', packedValue)
            value = -1 * value[0]
            self._ctx.getStakeFrame().allocateChunck(value)

class SubProcessor(OpProcessor):
    def __init__(self, context):
        super().__init__('sub')
        self._ctx = context

    def process(self, inst):
        super().process(inst)
        args = inst['args']
        if args['dest'] == 'rsp':
            value = int(args['value'], base=16)
            self._ctx.getStakeFrame().allocateChunck(value)
        else:
            pass # TODO

        return []

class PushProcessor(OpProcessor):
    def __init__(self, context):
        super().__init__('push')
        self._ctx = context
        
    def process(self, instruction):
        super().process(instruction)

        param = instruction['args']['value']

        if fullmatch(r'^0x[0-9a-fA-F]+$', param[2:]):
            val = int(param, base=16)
        elif fullmatch(r'^\[0x[0-9a-fA-F]+\]$', param):
            raise NotImplementedError('Push of values from memory is not supported for this implementation') # TODO: Ask Professor
        else:
            val = self._ctx.getRegisterValue(param)

        value = Value(value=val)
        self._ctx.pushNewStackValue(value)

        return []

class LeaveProcessor(OpProcessor):
    def __init__(self):
        super().__init__('leave')

class RetProcessor(OpProcessor):
    def __init__(self, context):
        super().__init__('ret')
        self._ctx = context

    def process(self, instruction):
        super().process(instruction)
        self._ctx.inactivateFrame()

        return []
