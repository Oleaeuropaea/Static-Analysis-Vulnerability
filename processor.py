from leaProcessor import LeaProcessor

__all__ = ['Processor']

from context import Context
from opProcessor import InvalidInstructionError
from opProcessores import *
from callProcessor import CallProcessor
from stackFrame import Value
from utils import getRelativeOffset
from movProcessor import MovProcessor

def getVariables(vars):
    res = []
    for var in vars:
        if var['address'][:3] != 'rbp':
            raise Exception('Processor: Unexpected possibility!')

        addr = getRelativeOffset(var['address'])

        size = 0 if var['type'] == 'buffer' else var['bytes']

        val = Value(addr, name=var['name'], maxSize=var['bytes'], size=size)

        res.append(val)

    return res

# TODO Ask Gon√ßalo and Henrique about where parce rbp+0x50 to 0x50, and the address in 
#       a Value returned from the frame having or not the address or the offset
class Processor:
    def __init__(self, code, name='main', ctx = None):
        self._name = name
        self._ctx = ctx or Context(code)

    def process(self, instruction): # TODO: Change
        op = instruction['op']
        ctx = self._ctx

        if op == 'ret':
            processor = RetProcessor(ctx)
        elif op == 'leave':
            processor = LeaveProcessor()
        elif op == 'nop':
            processor = NopProcessor()
        elif op == 'push':
            processor = PushProcessor(ctx)
        elif op == 'call':
            processor = CallProcessor(ctx)
        elif op == 'mov':
            processor = MovProcessor(ctx)
        elif op == 'lea':
            processor = LeaProcessor(ctx)
        elif op == 'sub':
            processor = SubProcessor(ctx)
        elif op == 'add':
            processor = AddProcessor(ctx)
        else:
            raise InvalidInstructionError('Op code %s doesn\'t exits or it\'s not supported' % op)

        return processor.process(instruction)
    
    def run(self):
        ctx = self._ctx
        code = ctx.getCode(self._name)
        fres = []

        instsSeq = sorted(code['instructions'], key=lambda i: i['pos']) # Sequence of instructions

        ic = ctx.set_ic(2) # Instruction Counter (start at 2 because the "push %rbp" and "mov %rbp, %rsp" are automatically done)

        # TODO: Could exist a program that it doesn't need to allocate memory ??
        # Allocate memory needed in the stack
        # Assumption (given by specification): all the memory needed in the stack is allocated at the beginning of the function
        self.process(instsSeq[ic])
        ic = ctx.inc_ic()

        # Allocate variables in the memory allocated above
        vars = getVariables(code['variables'])
        for var in vars:
            self._ctx.insert(var)

        while ic < (len(instsSeq) - 1):
            ic = ctx.get_ic()
            res = self.process(instsSeq[ic])
            ic = ctx.inc_ic()
            fres.extend(res)

        ic = ctx.get_ic()
        res = self.process(instsSeq[ic])
        fres.extend(res)

        return fres
