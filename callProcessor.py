__all__ = ['CallProcessor']

from opProcessor import OpProcessor

## RDI,RSI,RDX,RCX,R8,R9 + stack for arguments beyond the 6th (with 7th argument being the one on top)

def bufflen(ctx, val):
    size = val.size

    while not val.isEnded:
        val = ctx.nextStackValue(val)
        if val is None: # If the stack end was achieved
            size = 2 * size # The size turns to be twice the original one, just to ensure that is detected
            break
        size = size + val.size

    return size

# char *gets(char *buff)
def gets(ctx):
    buffOffset = ctx.getRegisterValue('rdi')
    buff = ctx.getStackValue(buffOffset)

    buff.size = None # Size is unlimited

    vulns = ctx.checkVuln(buff)

    for vuln in vulns:
        vuln.setdefault('fnname', 'gets')

    return vulns

# char *strcpy(char *dest, const char *src)
def strcpy(ctx):
    destOffset = ctx.getRegisterValue('rdi')
    dest = ctx.getStackValue(destOffset)

    srcOffset = ctx.getRegisterValue('rsi')
    src = ctx.getStackValue(srcOffset)

    size = bufflen(ctx, src)
    dest.size = size

    vulns = ctx.checkVuln(dest, size)

    for vuln in vulns:
        vuln.setdefault('fnname', 'strcpy')

    return vulns

# char *strcat(char *dest, const char *src)
def strcat(ctx):
    destOffset = ctx.getRegisterValue('rdi')
    dest = ctx.getStackValue(destOffset)

    srcOffset = ctx.getRegisterValue('rsi')
    src = ctx.getStackValue(srcOffset)

    size = bufflen(ctx, src) + bufflen(ctx, dest) - 1 # Minus one of the '\0' characters
    dest.size = size

    vulns = ctx.checkVuln(dest, size)

    for vuln in vulns:
        vuln.setdefault('fnname', 'strcat')

    return vulns

# char *fgets(char *buff, int n, FILE *stream)
def fgets(ctx):
    buffOffset = ctx.getRegisterValue('rdi')
    buff = ctx.getStackValue(buffOffset)
    n = ctx.getRegisterValue('rsi')

    buff.size = n

    vulns = ctx.checkVuln(buff, n)

    for vuln in vulns:
        vuln.setdefault('fnname', 'fgets')

    return vulns

# char *strncpy(char *dest, const char *src, size_t n)
def strncpy(ctx):
    destOffset = ctx.getRegisterValue('rdi')
    dest = ctx.getStackValue(destOffset)
    n = ctx.getRegisterValue('rdx')

    srcOffset = ctx.getRegisterValue('rsi')
    src = ctx.getStackValue(srcOffset)

    size = bufflen(ctx, src)
    size = size if size < n else n
    dest.size = size

    if size == n:
        dest.isEnded = False

    vulns = ctx.checkVuln(dest, size)

    for vuln in vulns:
        vuln.setdefault('fnname', 'strncpy')

    return vulns

# char *strncat(char *dest, const char *src, size_t n)
#   n âˆ’ This is the maximum number of characters to be appended
def strncat(ctx):
    destOffset = ctx.getRegisterValue('rdi')
    dest = ctx.getStackValue(destOffset)
    size = bufflen(ctx, dest)

    srcOffset = ctx.getRegisterValue('rsi')
    src = ctx.getStackValue(srcOffset)

    n = ctx.getRegisterValue('rdx')

    sizeToAdd = bufflen(ctx, src) - 1 # Minus one of the '\0' characters
    sizeToAdd = sizeToAdd if sizeToAdd < n else n
    dest.size = sizeToAdd

    vulns = ctx.checkVuln(dest, size + sizeToAdd)

    for vuln in vulns:
        vuln.setdefault('fnname', 'strncat')

    return vulns

class CallProcessor(OpProcessor):
    def __init__(self, context):
        super().__init__('call')
        self._ctx = context

    def process(self, instruction):
        super().process(instruction)
        fnname = instruction['args']['fnname']

        if fnname == '<gets@plt>':
            processor = gets
        elif fnname == '<strcpy@plt>':
            processor = strcpy
        elif fnname == '<strcat@plt>':
            processor = strcat
        elif fnname == '<fgets@plt>':
            processor = fgets
        elif fnname == '<strncpy@plt>':
            processor = strncpy
        elif fnname == '<strncat@plt>':
            processor = strncat
        else:
            raise NotImplementedError('Function %s is not supported' % fnname)

        vulns = processor(self._ctx)

        for vuln in vulns:
            vuln.setdefault('address', instruction['address'])

        return vulns
